# Task 07: Package Management

This is the last guided task. Here, we'll put together the previous two tasks,
and build a project containing x86 assembly using the packaged NASM we created
in the previous task. To do this, we will use the Zig package manager.

Unlike other languages' package managers (npm, cargo, etc), the Zig package
manager does not run on centralized package repositories. Instead, every
dependency is directly referenced through a URL to a tarball. You can also
reference a dependency as a relative path, which is what we'll do here.

The package manager works using files named `build.zig.zon`, which live in the
same directory as `build.zig` scripts. ZON (Zig Object Notation) is a subset of
Zig expression syntax. As a first step, you should go back to task 6 and create a
`build.zig.zon` file there. This will tell the Zig package manager that this
directory, when used as the root of a package, contains a Zig build script which
should be evaluated. Every `Step.Compile` which the script installs is exposed to
build scripts which depend on it. A skeleton showcasing the structure of `build.zig.zon`
is generated by `zig init`. For the NASM package itself, you don't need any dependencies.

Next, you'll need to create another `build.zig.zon` file in this directory. This
one should have an entry in `dependencies` which references the directory containing
your NASM package. It should look something like this:

```
.dependencies = .{
    .nasm = .{
        .path = "../06_nasm/",
    },
},
```

This tells Zig that the build script in this directory has a dependency named `nasm`,
which is found at the relative path `../06_nasm/`. We can then reference this package
from within our build script.

To use a dependency, call `b.dependency`. This takes two arguments. The first is the
dependency name - in this case `nasm` - and the second is a list of options to pass
to the dependency. These options are treated like `-Dfoo` options to your build script,
so, for instance, are read by `standardTargetOptions` and `standardOptimizeOption`. It's
conventional for packages to use these two functions, and for that reason, a pretty
common set of options to pass is the following:

```
b.dependency("foo", .{
    .target = target,
    .optimize = optimize,
});
```

However, in this case, that actually wouldn't be correct. We don't want to compile NASM
for the architecture our final binary is targeting: we're using it in the build process,
so we want to build it for the native target (which is the default if you don't pass one).
Also, since we already know that NASM works, there's no point building it in `Debug` mode.
So, instead, we'll pass no target, and we'll hardcode `.optimize = .ReleaseFast`.

On the object returned by `dependency`, you can then get access to compilation artifacts
installed by the build script. For instance, calling `.artifact("nasm")` on the returned
object will give you the `Step.Compile` named "nasm". Using this, and using `b.addRunArtifact`
to instruct the build system to run the NASM artifact it built, and you can link this into
a C artifact like you did in task 5. This directory has the same files to build as task 5
did - you should now be able to get it working *without* a dependency on a system installation
of NASM.

# Conclusion

This concludes the guided part of this workshop. It's worth thinking about what you've created
here, because it's quite non-trivial! There are 5 build steps here: two generating config headers
for NASM, one compiling NASM for the host system, one running NASM to assemble some code into an
object, and one compiling a final binary from that object and some C code. These steps are linked
implicitly through the way they reference one another's outputs. They are all integrated with the
cache system: the config headers are not regenerated unless they've changed, NASM is not rebuilt
unless something has changed, the assembly file is not re-assembled unless it or NASM has changed,
and the final binary is not rebuilt unless the C source or assembled object has changed.

If you'd like, you can now move onto trying to build a project of your choice (or multiple!) with
the Zig build system. The sky's the limit here; don't be afraid to ask for help if you need it.

If you'd prefer, you can instead play around with this exercise a little more before moving on.
Here are some ideas for functionality you could add:

* Pass the correct object format to NASM (elf64/macho64/win64) based on the target from `standardTargetOptions`.
* Abstract the "run NASM" step logic into a function, and assemble multiple files.
* Try adding some C++ code. Just pass C++ files to `addCSourceFiles`, and use `linkLibCpp` if needed.
* Using the `root_source_file` field on `addExecutable`, try adding some Zig code which interacts with C and/or assembly.
